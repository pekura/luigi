<div class="{hideNav? 'no-nav' : ''} {hideSideNav? 'no-side-nav':''}">
  <div style="--top-nav-height: {topNavHeight}; --top-nav-height-tab: {topNavHeightTab}; --left-nav-width: {leftNavWidth}; --left-nav-width-collapsed: {leftNavWidthCollapsed}"
    class="iframeContainer {splitViewDisplayed?'lui-split-view':''} {splitViewCollapsed?'lui-collapsed':''}"
    use:init
  >
    <Backdrop area="main"></Backdrop>
  </div>
</div>
<script type="text/javascript">
  import Backdrop from './Backdrop.html';
  import {
    afterUpdate,
    onMount,
    setContext,
    createEventDispatcher
  } from 'svelte';
  import {
    GenericHelpers,
    StateHelpers,
    RoutingHelpers,
    IframeHelpers,
    AuthHelpers
  } from './utilities/helpers';
  import { LuigiI18N, LuigiConfig, LuigiElements } from './core-api';
  import { Navigation } from './navigation/services/navigation';
  import { Routing } from './services/routing';
  import { Iframe } from './services/iframe';
  import { ViewGroupPreloading } from './services/preloading';
  import { MessagesListeners } from './services/messages-listeners';

  const dispatch = createEventDispatcher();

  export let store;

  export let topNavHeight = '0px';
  export let topNavHeightTab = '0px';
  export let leftNavWidth = '0px';
  export let leftNavWidthCollapsed = '0px';

  let showLoadingIndicator = false;

  /// MFs
  let modalIframe;
  let modal;
  let context;
  let nodeParams;
  let pathParams;
  let urlParamsRaw;
  let currentNode;
  let viewUrl;
  let viewGroup;
  let isolateView;
  let previousNodeValues;
  let isNavigateBack = false;
  let goBackContext;
  let navigationPath;
  let contentNode;
  let preservedViews = [];
  let unsavedChanges = {
    isDirty: false,
    persistUrl: null
  };
  let simpleSlideInNav;
  let responsiveNavSetting;
  let tabNav;
  let resizeTabNavToggle = false;

  export let splitViewDisplayed;
  export let splitViewCollapsed;

  export let getUnsavedChangesModalPromise = () => {
    return new Promise(resolve => {
        resolve();
    });
  };

  export let shouldShowUnsavedChangesModal = () => {
    return false;
  };

  export let showUnsavedChangesModal = () => {
    return new Promise(resolve => {
      resolve();
    });
  };

  export const prepareInternalData = config => {
    const internalData = {
      isNavigateBack: isNavigateBack,
      viewStackSize: preservedViews.length,
      currentLocale: LuigiI18N.getCurrentLocale(),
      clientPermissions: config.iframe.luigi.nextViewUrl
        ? config.iframe.luigi.nextClientPermissions
        : config.iframe.luigi.clientPermissions
    };
    IframeHelpers.specialIframeTypes
      .map(o => o.iframeConfigKey)
      .forEach(key => {
        internalData[key] = config[key] || false;
      });
    return internalData;
  };

  const sendAuthDataToClient = authData => {
    const message = {
      msg: 'luigi.auth.tokenIssued',
      authData
    };
    IframeHelpers.broadcastMessageToAllIframes(message);
  };

  //// NAVIGATION

  const addPreserveView = (data, config) => {
    if (data.params.preserveView || data.params.viewgroup) {
      const nextPath = buildPath(data.params);
      $: preservedViews.push({
        path: Routing.getNodePath(currentNode, urlParamsRaw),
        nextPath: nextPath.startsWith('/') ? nextPath : '/' + nextPath,
        context
      });
      //mark iframe with pv if there is a preserved view situation
      config.iframe['pv'] = 'pv';
    }
  };

  export function handleNavigation(data, config) {
    let path = buildPath(data.params);
    path = GenericHelpers.addLeadingSlash(path);

    addPreserveView(data, config);
    Routing.navigateTo(path); //navigate to the raw path. Any errors/alerts are handled later
  }

  const removeQueryParams = str => str.split('?')[0];

  const isValidBackRoute = (preservedViews, routeHash) => {
    if (preservedViews.length === 0) {
      return false;
    }
    // we're only checking the previous goBack state and
    // compare it with the new route
    const routePath = routeHash.startsWith('/') ? routeHash : `/${routeHash}`;
    const lastPreservedView = [...preservedViews].pop();
    const paths = [
      removeQueryParams(lastPreservedView.path),
      removeQueryParams(lastPreservedView.nextPath)
    ];
    return paths.includes(removeQueryParams(routePath));
  };

  //TODO refactor
  const getComponentWrapper = () => {
    return {
      get: () => {
        return {
          unsavedChanges,
          hideNav,
          viewUrl,
          nodeParams,
          viewGroup,
          urlParamsRaw,
          currentNode,
          navigationPath,
          context,
          pathParams,
          hideSideNav,
          isolateView,
          previousNodeValues,
          showLoadingIndicator,
          tabNav,
          isNavigateBack,
          goBackContext
        };
      },
      set: obj => {
        if (obj) {
          Object.getOwnPropertyNames(obj).forEach(prop => {
            if (prop === 'hideNav') {
              hideNav = obj.hideNav;
            } else if (prop === 'viewUrl') {
              viewUrl = obj.viewUrl;
            } else if (prop === 'nodeParams') {
              nodeParams = obj.nodeParams;
            } else if (prop === 'viewGroup') {
              viewGroup = obj.viewGroup;
            } else if (prop === 'urlParamsRaw') {
              urlParamsRaw = obj.urlParamsRaw;
            } else if (prop === 'currentNode') {
              currentNode = obj.currentNode;
            } else if (prop === 'navigationPath') {
              navigationPath = obj.navigationPath;
            } else if (prop === 'context') {
              context = obj.context;
            } else if (prop === 'pathParams') {
              pathParams = obj.pathParams;
            } else if (prop === 'hideSideNav') {
              hideSideNav = obj.hideSideNav;
            } else if (prop === 'isolateView') {
              isolateView = obj.isolateView;
            } else if (prop === 'previousNodeValues') {
              previousNodeValues = obj.previousNodeValues;
            } else if (prop === 'showLoadingIndicator') {
              showLoadingIndicator = obj.showLoadingIndicator;
            } else if (prop === 'tabNav') {
              tabNav = obj.tabNav;
            } else if (prop === 'isNavigateBack') {
              isNavigateBack = obj.isNavigateBack;
            } else if (prop === 'goBackContext') {
              goBackContext = obj.goBackContext;
            }
          });
        }
      },
      getUnsavedChangesModalPromise,
      shouldShowUnsavedChangesModal,
      showUnsavedChangesModal,
      prepareInternalData,
      dispatch
    };
  };

  const enableRouting = (node, config) => {
    // initial route handling
    StateHelpers.doOnStoreChange(
      store,
      () => {
        LuigiConfig._configModificationTimestamp = new Date();
        const currentPath = Routing.getCurrentPath();
        Routing.handleRouteChange(
          currentPath,
          getComponentWrapper(),
          node,
          config
        ).then(() => {
          dispatch('routeChanged', getComponentWrapper().get());
        });
      },
      ['navigation.nodes']
    );

    // subsequential route handling
    RoutingHelpers.addRouteChangeListener(path => {
      const pv = preservedViews;
      if (!isValidBackRoute(pv, path)) {
        preservedViews = [];
        Iframe.removeInactiveIframes(node);
      }

      Routing.handleRouteChange(path, getComponentWrapper(), node, config).then(() => {
        dispatch('routeChanged', getComponentWrapper().get());
      });
    });
  };

  const getSubPath = node => {
    return GenericHelpers.replaceVars(
      Routing.getNodePath(node),
      pathParams,
      ':',
      false
    );
  };

  export function buildPath(params) {
    let path = params.link;
    if (params.fromClosestContext) {
      // from the closest navigation context
      const node = [...navigationPath]
        .reverse()
        .find(n => n.navigationContext && n.navigationContext.length > 0);
      path = Routing.concatenatePath(getSubPath(node), params.link);
    } else if (params.fromContext) {
      // from a given navigation context
      const navigationContext = params.fromContext;
      const node = navigationPath.find(
        n => navigationContext === n.navigationContext
      );
      path = Routing.concatenatePath(getSubPath(node), params.link);
    } else if (params.relative) {
      // relative
      path = Routing.concatenatePath(getSubPath(currentNode), params.link);
    }

    if (params.nodeParams && Object.keys(params.nodeParams).length) {
      path += '?';
      Object.entries(params.nodeParams).forEach(entry => {
        path +=
          encodeURIComponent(
            RoutingHelpers.getContentViewParamPrefix() + entry[0]
          ) +
          '=' +
          encodeURIComponent(entry[1]) +
          '&';
      });
    }
    return path;
  }

  /// RESIZING

  let hideNav;
  let hideSideNav;

  export function sendContextToClient(config, goBackContext = {}) {
    if (!config.iframe) {
      console.info('iframe does not exist, not able to send context.');
      return;
    }
    const message = {
      msg: 'luigi.init',
      context: JSON.stringify(
        Object.assign({}, config.context || context, goBackContext)
      ),
      nodeParams: JSON.stringify(
        Object.assign({}, config.nodeParams || nodeParams)
      ),
      pathParams: JSON.stringify(
        Object.assign({}, config.pathParams || pathParams)
      ),
      internal: JSON.stringify(prepareInternalData(config)),
      authData: AuthHelpers.getStoredAuthData()
    };
    IframeHelpers.sendMessageToIframe(config.iframe, message);
  }

  function init(node) {
    const isolateAllViews = LuigiConfig.getConfigValue(
      'navigation.defaults.isolateView'
    );
    const config = {
      iframe: null,
      navigateOk: null,
      builderCompatibilityMode: Boolean(window.builderCompatibilityMode),
      isolateAllViews
    };
    LuigiI18N.addCurrentLocaleChangeListener(locale => {
      const message = {
        msg: 'luigi.current-locale-changed',
        currentLocale: locale
      };
      IframeHelpers.broadcastMessageToAllIframes(message);
    });

    window.addEventListener('message', async e => {
      const iframe = IframeHelpers.getValidMessageSource(e);
      if (!iframe) return;

      if ('custom' === e.data.msg) {
        const customMessagesListeners =
          LuigiConfig.getConfigValue('communication.customMessagesListeners') ||
          {};
        const message = MessagesListeners.convertCustomMessageInternalToUser(
          e.data
        );
        const customMessageListener = customMessagesListeners[message.id];
        if (typeof customMessageListener === 'function') {
          const microfrontend = LuigiElements.getMicrofrontends().find(
            mf => mf.id === e.source.frameElement.luigi.id
          );

          customMessageListener(
            message,
            microfrontend,
            GenericHelpers.removeInternalProperties(iframe.luigi.currentNode)
          );
        }
      }

      if ('luigi.navigate.ok' === e.data.msg) {
        iframe.luigi.viewUrl = iframe.luigi.nextViewUrl;
        iframe.luigi.nextViewUrl = '';
        iframe.luigi.clientPermissions = iframe.luigi.nextClientPermissions;
        delete iframe.luigi.nextClientPermissions;
        config.navigateOk = true;

        ViewGroupPreloading.preload();
      }

      if ('luigi.get-context' === e.data.msg) {
        if (
          config.iframe &&
          IframeHelpers.isMessageSource(e, config.iframe)
        ) {
          sendContextToClient(config, {});
          const loadingIndicatorAutoHideEnabled =
            !currentNode ||
            !currentNode.loadingIndicator ||
            currentNode.loadingIndicator.hideAutomatically !== false;
          if (loadingIndicatorAutoHideEnabled) {
            showLoadingIndicator = false;
          }
          dispatch('showLoadingIndicator', showLoadingIndicator);

          ViewGroupPreloading.preload();
        } else if (iframe.luigi.preloading) {
          // set empty context to an existing but inactive iframe; this is a valid use case (view group pre-loading)
          sendContextToClient(
            {
              iframe: iframe,
              context: {},
              nodeParams: {},
              pathParams: {},
              internal: {}
            },
            {}
          );
        }
        ViewGroupPreloading.viewGroupLoaded(iframe);
      }

      if ('luigi.show-loading-indicator' === e.data.msg) {
        showLoadingIndicator = true;
        dispatch('showLoadingIndicator', showLoadingIndicator);
      }

      if ('luigi.hide-loading-indicator' === e.data.msg) {
        showLoadingIndicator = false;
        dispatch('showLoadingIndicator', showLoadingIndicator);
      }

      if ('luigi.navigation.open' === e.data.msg) {
        isNavigateBack = false;
        if (e.data.params.modal === undefined && e.data.params.splitView === undefined) {
          getUnsavedChangesModalPromise().then(() => {
            handleNavigation(e.data, config);
          });
        }
      }

      if ('luigi.navigation.back' === e.data.msg) {
        if (IframeHelpers.isMessageSource(e, Iframe.getActiveIframe(IframeHelpers.getIframeContainer()))) {
          // go back: context from the view
          if (preservedViews && preservedViews.length) {
            getUnsavedChangesModalPromise().then(() => {
              // remove current active iframe and data
              Iframe.setActiveIframeToPrevious(node);
              const previousActiveIframeData = preservedViews.pop();
              // set new active iframe and preservedViews
              config.iframe = Iframe.getActiveIframe(node);
              isNavigateBack = true;
              preservedViews = preservedViews;
              goBackContext =
                e.data.goBackContext && JSON.parse(e.data.goBackContext);
              // TODO: check if getNavigationPath or history pop to update hash / path
              handleNavigation(
                { params: { link: previousActiveIframeData.path } },
                config
              );
            });
          } else {
            if (e.data.goBackContext) {
              console.warn(
                `Warning: goBack() does not support goBackContext value. This is available only when using preserved views feature. Documentation: https://github.com/SAP/luigi/blob/master/docs/luigi-client-api.md#navigate`
              );
            }
            // TODO: does not work with default child node behavior, fixed by #216
            window.history.back();
          }
        } else {
          sendContextToClient(config, {
            goBackContext:
              e.data.goBackContext && JSON.parse(e.data.goBackContext)
          });
        }
      }

      if ('luigi.auth.tokenIssued' === e.data.msg) {
        sendAuthDataToClient(e.data.authData);
      }

      if ('luigi.navigation.pathExists' === e.data.msg) {
        const data = e.data.data;
        const path = buildPath(data);
        const pathData = await Navigation.getNavigationPath(
          LuigiConfig.getConfigValueAsync('navigation.nodes'),
          path
        );
        const message = {
          msg: 'luigi.navigation.pathExists.answer',
          data: {
            correlationId: data.id,
            pathExists: pathData.isExistingRoute
          }
        };
        IframeHelpers.sendMessageToIframe(iframe, message);
      }

      if ('luigi.ux.set-current-locale' === e.data.msg) {
        if (
          iframe.luigi.clientPermissions &&
          iframe.luigi.clientPermissions.changeCurrentLocale
        ) {
          const { currentLocale } = e.data.data;
          if (currentLocale) {
            LuigiI18N.setCurrentLocale(currentLocale);
          }
        } else {
          console.error(
            'Current local change from client declined because client permission changeCurrentLocale is not set for this view.'
          );
        }
      }

    });

    // listeners are not automatically removed — cancel
    // them to prevent memory leaks
    // this.on('destroy', storeListener.cancel);
    enableRouting(node, config);
  }

  onMount(() => {});

  afterUpdate(() => {});
</script>

<style type="text/scss">
  /*Mixins*/
  @import 'styles/mixins';

  $desktopMinWidth: 600px;

  :global(html) {
    box-sizing: border-box;
    font-size: 14px;
    position: fixed;
    width: 100%;
    min-height: 100%;
  }
  :global(body) {
    -webkit-font-smoothing: antialiased;
    margin: 0;
    line-height: 1.42857;
  }
  :global(*) {
    box-sizing: inherit;
  }
  :global(*:before),
  :global(*:after) {
    box-sizing: inherit;
  }
  div :global(div) {
    font-family: '72', sans-serif;
  }

  :global(a) {
    cursor: pointer;
  }
  :global([luigi-app-loading-indicator]) {
    z-index: 10;
    background-color: var(--fd-background-color);
    padding-top: 30vh;
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  :global([luigi-app-loading-indicator].hidden) {
    visibility: hidden;
    opacity: 0;
    @include transition(visibility 0s 0.3s, opacity 0.3s linear);
  }

  .iframeContainer {
    position: absolute;
    top: var(--top-nav-height);
    left: var(--left-nav-width);
    bottom: 0;
    right: 0;
    width: auto;
    min-width: auto;
    min-height: auto;
    display: block;
  }

  .iframeContainer {
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  .iframeContainer :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
    overflow: hidden;
    margin-bottom: -5px;
  }
  .iframeContainerNoNav {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    right: 0;
  }
  .iframeContainerNoNav :global(iframe) {
    border: none;
    width: 100%;
    height: 100%;
  }

  .iframeContainerTabNav {
    top: calc(var(--top-nav-height) + var(--top-nav-height-tab));
  }

  .spinnerContainer {
    background: rgba(243, 244, 245, 0.8);
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .no-nav {
    .iframeContainer {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
    }
  }

  .no-side-nav {
    .iframeContainer {
      left: 0;
    }
  }

  :global(html.luigi-app-in-custom-container) {
    position: relative;

    [luigi-app-root] {
      position: relative;
      overflow: hidden;
    }

    .no-nav,
    .no-side-nav {
      .iframeContainer {
        position: absolute;
      }
    }
  }
</style>
